import { Request, Response } from 'express';
import { post } from './job.controller';
import { fetchOrders } from '../repository/order.repository';
import { mapOrderForMBA, mapOrderForCS } from '../service/order.service';
import { UploadCFTrainingData, UploadCSTrainingData, uploadMBATrainingData } from '../service/s3.service';
import { writeLog } from '../service/log.service';
import CustomError from '../errors/custom.error';

jest.mock('../repository/order.repository');
jest.mock('../service/order.service');
jest.mock('../service/s3.service');
jest.mock('../service/log.service');
jest.mock('../utils/logger.utils');

describe('Order Controller - post function', () => {
  let response: Partial<Response>;

  beforeEach(() => {
    response = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };
    jest.clearAllMocks();
  });

  it('should upload JSON and CSV data to S3 and log success', async () => {
    const ordersMock = { results: [{ id: 'order1' }, { id: 'order2' }] };
    const productsMock = { results: [{ id: 'product1' }, { id: 'product2' }] };
    const mappedCFData = { associations: [{ id: 'cf-association' }] };
    const mbaAssociations = [{ id: 'mba-association' }];
    const csOrders = [{ id: 'cs-order' }];

    (fetchOrders as jest.Mock).mockResolvedValue(ordersMock);
    (UploadCFTrainingData as jest.Mock).mockResolvedValue(true);
    (mapOrderForMBA as jest.Mock).mockReturnValue(mbaAssociations);
    (uploadMBATrainingData as jest.Mock).mockResolvedValue(true);
    (mapOrderForCS as jest.Mock).mockReturnValue(csOrders);
    (UploadCSTrainingData as jest.Mock).mockResolvedValue(true);

    await post({} as Request, response as Response);

    // expect(fetchOrders).toHaveBeenCalled();
    // expect(UploadCFTrainingData).toHaveBeenCalledWith(mappedCFData);

    expect(mapOrderForMBA).toHaveBeenCalledWith(ordersMock);
    expect(uploadMBATrainingData).toHaveBeenCalledWith({ associations: mbaAssociations });
    expect(mapOrderForCS).toHaveBeenCalledWith(ordersMock);
    expect(UploadCSTrainingData).toHaveBeenCalledWith(csOrders);

    expect(writeLog).toHaveBeenCalledWith(
      'Uploaded order associations JSON, CF JSON, and CS CSV data to S3',
      2, // totalOrdersProcessed based on ordersMock
      expect.any(Number),
      true,  // isMBAUploadSuccessful
      true,  // isCSUploadSuccessful
      true   // isCFUploadSuccessful
    );

    expect(response.status).toHaveBeenCalledWith(200);
    expect(response.json).toHaveBeenCalledWith({
      message: 'Data upload successful',
    });
  });

  it('should handle error and log failure', async () => {
    const error = new Error('Fetching orders failed');
    (fetchOrders as jest.Mock).mockRejectedValue(error);

    try {
      await post({} as Request, response as Response);
    } catch (err: any) {
      expect(err).toBeInstanceOf(CustomError);
      expect(err.message).toBe('Internal Server Error');
    }

    expect(writeLog).toHaveBeenCalledWith(
      'Internal Server Error',
      0, // No orders processed due to error
      expect.any(Number),
      false, // isMBAUploadSuccessful
      false, // isCSUploadSuccessful
      false  // isCFUploadSuccessful
    );
  });

  it('should throw CustomError if CustomError is thrown in try block', async () => {
    const customError = new CustomError(400, 'Custom Error');
    (fetchOrders as jest.Mock).mockRejectedValue(customError);

    await expect(post({} as Request, response as Response)).rejects.toThrow(CustomError);

    expect(writeLog).toHaveBeenCalledWith(
      'Custom Error',
      0, // No orders processed on error
      expect.any(Number),
      false, // isMBAUploadSuccessful
      false, // isCSUploadSuccessful
      false  // isCFUploadSuccessful
    );
  });
});
